import "dotenv/config";
import OpenAI from "openai";
import fs from "fs/promises";
import path from "path";

const systemPrompt = `You are Soultrace's HTML painting agent. Based on a given prompt, generate a complete standalone HTML document that visually renders an imaginative and beautiful scene using HTML and CSS. The resulting HTML/CSS should create a striking and attractive picture.
Guidelines:
- Respond with valid HTML (including <!DOCTYPE html>, <html>, <head>, <body>).
- Inline all CSS within a <style> tag in <head>.
- Use semantic HTML elements when sensible.
- Avoid external resources unless absolutely necessary; prefer gradients, SVG, or free image URLs supplied in the prompt arguments.
- Keep total HTML under ~10KB.
- Never include <script> tags.
- Celebrate vibrant gradients, subtle animation via CSS keyframes if helpful, and accessible contrast.`;

console.log("systemPrompt at paintingAgent.js", systemPrompt);

const defaultModel = "gpt-5";

// Initialize OpenAI client
const client = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Add back the fallbackHtml function that was deleted
const fallbackHtml = ({
  prompt,
  palette = [],
  aspectRatio = "16:9",
}) => `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Soultrace Painted Scene</title>
  </head>
  <body>
    <h1>Error Getting HTML</h1>
    <p>Prompt: ${prompt}</p>
    <p>Palette: ${palette.join(", ") || "N/A"}</p>
    <p>Aspect Ratio: ${aspectRatio}</p>
  </body>
</html>`;

// Create output directory for HTML files
const OUTPUT_DIR = path.join(process.cwd(), "generated-paintings");

console.log("OUTPUT_DIR", OUTPUT_DIR);

// Ensure output directory exists
async function ensureOutputDir() {
  try {
    await fs.access(OUTPUT_DIR);
  } catch {
    await fs.mkdir(OUTPUT_DIR, { recursive: true });
    console.log(`Created directory: ${OUTPUT_DIR}`);
  }
}

// Helper function to create a safe filename from prompt
function createSafeFilename(prompt, timestamp = Date.now()) {
  const cleanPrompt = prompt
    .replace(/[^a-zA-Z0-9\s]/g, "") // Remove special characters
    .replace(/\s+/g, "-") // Replace spaces with hyphens
    .toLowerCase()
    .substring(0, 50); // Limit length

  return `painting-${cleanPrompt}-${timestamp}.html`;
}

// Helper function to save HTML to file
async function saveHtmlToFile(htmlContent, prompt, metadata = {}) {
  try {
    await ensureOutputDir();

    const filename = createSafeFilename(prompt);
    const filepath = path.join(OUTPUT_DIR, filename);

    // Add metadata as HTML comment at the top
    const metadataComment = `<!--
Generated by Soultrace Painting Agent
Timestamp: ${new Date().toISOString()}
Prompt: ${prompt}
Model: ${metadata.model || "unknown"}
Response ID: ${metadata.responseId || "unknown"}
Tokens Used: ${JSON.stringify(metadata.tokens || {})}
-->
`;

    const finalHtml = metadataComment + htmlContent;

    await fs.writeFile(filepath, finalHtml, "utf-8");
    console.log(`[paintingAgent] Saved HTML painting to: ${filepath}`);

    return filepath;
  } catch (error) {
    console.error(`[paintingAgent] Failed to save HTML file:`, error);
    return null;
  }
}

console.log("paintingAgent.js loaded successfully");

export async function generateHtmlPainting({ prompt, palette, aspectRatio }) {
  const effectivePrompt = prompt?.trim().length ? prompt : "";

  if (!process.env.OPENAI_API_KEY) {
    console.log("[paintingAgent] No OpenAI API key, using fallback");

    const fallbackHtmlContent = fallbackHtml({
      prompt: effectivePrompt,
      palette,
      aspectRatio,
    });

    console.log(
      "[paintingAgent] Generated fallback HTML, length:",
      fallbackHtmlContent.length
    );

    // Save fallback HTML too
    await saveHtmlToFile(fallbackHtmlContent, effectivePrompt, {
      model: "fallback",
    });

    return {
      html: fallbackHtmlContent,
      meta: {
        model: "fallback",
        usedOpenAI: false,
      },
    };
  }

  // console.log("[paintingAgent] Making OpenAI API call...");

  try {
    // Use the new OpenAI Responses API
    const response = await client.responses.create({
      model: defaultModel,
      instructions: systemPrompt,
      input: `Prompt: ${effectivePrompt}\nSuggested palette: ${
        (palette ?? []).join(", ") || "N/A"
      }\nDesired aspect ratio: ${aspectRatio ?? "16:9"}\nReturn HTML now.`,
      max_output_tokens: 10000, // Increased from 3600
    });

    // Check if response is incomplete due to token limit
    if (
      response.status === "incomplete" &&
      response.incomplete_details?.reason === "max_output_tokens"
    ) {
      console.warn("[paintingAgent] Response was truncated due to token limit");
    }

    // Try to extract HTML content from the response
    let htmlContent;

    // First try the output_text field directly (as seen in terminal output)
    if (response.output_text) {
      htmlContent = response.output_text;
    } else {
      // Fallback to the nested structure
      const messageOutput = response.output.find(
        (item) => item.type === "message"
      );
      const textContent = messageOutput?.content?.find(
        (content) => content.type === "output_text"
      );
      htmlContent = textContent?.text;
    }

    if (!htmlContent) {
      throw new Error("OpenAI response missing HTML content");
    }

    // If the HTML is incomplete, try to close unclosed tags
    if (response.status === "incomplete") {
      htmlContent = ensureValidHtml(htmlContent);
    }

    const metadata = {
      model: response.model || defaultModel,
      responseId: response.id,
      tokens: response.usage,
      incomplete: response.status === "incomplete",
    };

    return {
      html: htmlContent,
      meta: {
        ...metadata,
        usedOpenAI: true,
      },
    };
  } catch (error) {
    console.error("[paintingAgent] Error occurred:", error);

    const fallbackHtmlContent = fallbackHtml({
      prompt: `${effectivePrompt} (fallback rendering)`,
      palette,
      aspectRatio,
    });

    return {
      html: fallbackHtmlContent,
      meta: {
        model: "fallback",
        usedOpenAI: false,
        error: String(error),
      },
    };
  }
}

// Helper function to ensure HTML is valid even if truncated
function ensureValidHtml(html) {
  // Basic HTML completion for truncated responses
  if (!html.includes("</html>")) {
    // Count unclosed tags and try to close them
    const openTags = html.match(/<(?!\/)[^>]+>/g) || [];
    const closeTags = html.match(/<\/[^>]+>/g) || [];

    // Simple approach: if missing </html>, try to close common tags
    if (!html.includes("</style>") && html.includes("<style>")) {
      html += "\n</style>";
    }
    if (!html.includes("</head>") && html.includes("<head>")) {
      html += "\n</head>";
    }
    if (!html.includes("</body>") && html.includes("<body>")) {
      html += "\n</body>";
    }
    if (!html.includes("</html>")) {
      html += "\n</html>";
    }
  }

  return html;
}
